# D2T1:单词检查(1)- 顺序表实现

## 1.内容和目的 

许多应用程序，如字处理软件，邮件客户端等，都包含了单词检查特性。单词检查是根据字典，找出输入文本中拼错的单词，我们认为凡是不出现在字典中的单词都是错误单词。不仅如此，一些检查程序还能给出类似拼错单词的修改建议单词。 例如字典由下面几个单词组成：

 bake cake main rain vase

如果输入文件中有词vake ，检查程序就能发现其是一个错误的单词，并且给出 bake, cake或vase做为修改建议单词。

修改建议单词可以采用如下生成技术：
1. 在每一个可能位置插入‘a-'z'中的一者
2. 删除单词中的一个字符
3. 用‘a'-'z'中的一者取代单词中的任一字符
 
很明显拼写检查程序的核心操作是在字典中查找某个单词，如果字典很大，性能无疑是非常关键的。

你写的程序要求读入字典文件，然后对一个输入文件的单词进行检查，列出其中的错误单词并给出修改建议。

课程设计必须采用如下技术完成并进行复杂度分析及性能比较。
- 朴素的算法,用线性表维护字典
- 使用二叉排序树维护字典
- 采用hash技术维护字典

本题要求使用顺序表实现。

## 2.分析与设计实现

此次课设为简化代码将使用std::string以及std::vector实现线性表字典。

我们将不使用`修改建议单词生成技术`。使用动态规划算法实现查找字典中单词是否满足12条件，使用匹配计数实现判断3条件。

### 动态规划状态设计

以下假设字符串`a`的大小大于字符串`b`的大小

为删掉`a`中的任意一个字符即等价于在`b`中任意位置插入任意一个字符，即12子问题是等价的。

我们只需解决在`a`中最多删一个字符能否匹配上`b`

设`f[n][i]`为在`a[0:n+i]`串中删除了`i`次，匹配到`b[0:n]`了没有

转移见代码：核心动态规划判断函数
```cpp
int cmp(const string &A,const string &B){
    const string& a=A.size()>B.size()?A:B;
    const string& b=A.size()>B.size()?B:A;
    if (a.size()-b.size()!=1) return false;//显然ab大小差为1
    vector<array<int,2>> DP(b.size()+1,{false,false});
    array<int,2>* const dp=&DP[1];//保证dp[-1]有定义
    dp[-1]={true,false};
    for (int i=0;i<b.size();i++){
            if (b[i]==a[i])//如果当前位置能匹配上，只能是a没删除的情况下转移
                dp[i][0]|=dp[i-1][0];
            if (b[i]==a[i+1])//如果能和删除后的位置匹配上，可以是删掉a[i]，也可以是之前就删掉了的
                dp[i][1]|=dp[i-1][0]||dp[i-1][1];
    }
    return DP[b.size()][1];
}
```

### 匹配计数

核心代码

```cpp
if (a.size()==b.size()){//长度相等
    int k=0;
    for (int i=0;i<a.size();i++)//逐位匹配
        if (a[i]==b[i]) k++;//匹配计数
    return k==a.size()-1;//如果匹配计数比长度小一，就是修改一个字母使其相等
}
```

## 3.性能分析

设单词长度为$L$，字典大小$n$，查询$q$次。

插入单词$O(L)$，插入$n$次单词。为$O(Ln)$

匹配计数和动态规划状态统计显然均为$O(L)$，查询单词为$O(L)$，查询$q$次，共为$O(Lq)$

则时间复杂度为$O(Ln+Lq)$

## 4.小结

实现了动态规划的算法

